/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NinjaCursorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var NinjaCursorPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.lastPos = { x: 0, y: 0, getScroll: () => 0 };
    this.events = ["keyup", "mouseup", "touchend"];
  }
  updateCursor() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const parentElement = (_d = (_c = (_b = (_a = this.app) == null ? void 0 : _a.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _b.currentMode) == null ? void 0 : _c.sizerEl) == null ? void 0 : _d.parentElement;
      const selection = activeWindow.getSelection();
      if (!parentElement || !selection || !selection.focusNode) {
        return;
      }
      const focusNode = selection.focusNode;
      const cursorRange = document.createRange();
      if (selection.focusOffset === 0) {
        cursorRange.setStart(focusNode, 0);
        cursorRange.setEnd(focusNode, 1);
      } else {
        cursorRange.setStart(focusNode, selection.focusOffset - 1);
        cursorRange.setEnd(focusNode, selection.focusOffset);
      }
      const cursorDOMRects = cursorRange.getClientRects();
      const cursorDomRect = cursorDOMRects.item(cursorDOMRects.length - 1);
      if (!cursorDomRect) {
        new import_obsidian.Notice("Could not find cursor position");
        return;
      }
      const lastClientX = this.lastPos.x;
      const lastClientY = this.lastPos.y - this.lastPos.getScroll();
      const currentClientX = selection.focusOffset ? cursorDomRect.right : cursorDomRect.left;
      const currentClientY = cursorDomRect.y;
      if (lastClientX == currentClientX && lastClientY == currentClientY) {
        return;
      }
      const dx = currentClientX - lastClientX;
      const dy = lastClientY - currentClientY;
      const cursorTailAngle = Math.atan2(dx, dy) + Math.PI / 2;
      const cursorDragDistance = Math.sqrt(dx * dx + dy * dy);
      this.cursorElement.style.setProperty("--cursor-drag-width", `${cursorDragDistance}px`);
      this.cursorElement.style.setProperty("--cursor-drag-angle", `${cursorTailAngle}rad`);
      this.cursorElement.style.setProperty("--cursor-height", `${cursorDomRect.height}px`);
      this.cursorElement.style.setProperty("--cursor-x1", `${lastClientX}px`);
      this.cursorElement.style.setProperty("--cursor-y1", `${lastClientY}px`);
      this.cursorElement.style.setProperty("--cursor-x2", `${currentClientX}px`);
      this.cursorElement.style.setProperty("--cursor-y2", `${currentClientY}px`);
      this.cursorElement.style.animation = "none";
      this.cursorElement.offsetHeight;
      this.cursorElement.style.animation = "";
      this.lastPos.x = currentClientX;
      this.lastPos.getScroll = () => parentElement == null ? void 0 : parentElement.scrollTop;
      this.lastPos.y = currentClientY + this.lastPos.getScroll();
    });
  }
  onload() {
    return __async(this, null, function* () {
      this.cursorElement = document.body.createSpan({
        cls: "dashing-cursor"
      });
      this.events.forEach((e) => this.registerDomEvent(window, e, this.updateCursor.bind(this)));
    });
  }
  onunload() {
  }
};
