# Introducción
> [!info] Definición
> Servicios cuyo cliente se ejecuta en un dispositivo móvil.

**Características que lo hacen único:**
- Ancho de banda y consumo limitados.
- Memoria y espacio de almacenamiento limitados.
- Autonomía limitada
- Conexión a la red no fiable
- A menudo la IP es privada
- Interfaz y escala diferente
- Sensores y conexiones diferentes disponibles

# SO
**¿En qué se diferencia un OS móvil de uno convencional?**
- <u>Acceso al hardware</u>: cada aplicación declara de antemano qué partes del hardware necesita. El usuario debe autorizarlo. Un intento de acceder a otro hardware es impedido por el SO.
- <u>Planificación de tareas</u>:
	- La multitarea está muy limitada
	- El SO puede eliminar tareas de la memoria si no están en primer plano
	- La ejecución de tareas en background es compleja y restrictiva.

## Ciclo de vida de una aplicación
- Una aplicación "en primer plano" es la que interactúa con el usuario (**solo una en cada momento**)
- Cuando una aplicación pasa a segundo plano, se detiene su ejecución.
	- El usuario no suele notarlo porque guardan/restauran su estado.
- Una aplicación en segundo plano puede ser finalizada por el operativo si necesita memoria.
- Si se necesita ejecutar código en segundo plano, debe programarse de forma específica para ello.

> [!warning] Importante en relación a los servicios web
> La aplicación puede ser interrumpida o incluso eliminada mientras una transacción de red estaba *a medias*.


## iOS: Estados y transiciones
![[_resources/Pasted image 20231128173156.png]]

![[_resources/Pasted image 20231128173205.png]]

## Android
### Componentes
La actividad pasa por varios estados. El sistema usa *callbacks* para notificar a la actividad sobre cuándo entra en un nuevo estado.

![[_resources/Pasted image 20231128174323.png]]

### Estados y transiciones
![[_resources/Pasted image 20231128173442.png]]

![[_resources/Pasted image 20231128173554.png]]

### Procesos
Concepto igual en Unix.
- En el dispositivo se están ejecutando siempre varios procesos.
- Una aplicación se ejecuta dentro de un proceso (raramente podrá usar varios)
	- El proceso ejecuta una JVM (UID diferente al de la App)
	- Todos los componentes de la aplicación se ejecutan en el mismo proceso
	- Pueden tener varios hilos
- Si el OS detiene y elimina un proceso, todos los componentes de la App mueren.

Cada proceso puede contener varios hilos para ejecutar simultáneamente diferentes funciones de un mismo o diferentes componentes.

#### Eliminación de procesos
Android tiene un algoritmo sofisticado para ordenar los procesos por imporancia, teniendo en cuenta qué componente de la aplicación está procesando y su relación con otras aplicaciones.
- Procesos *foreground* (actividades visibles, servicios enlazados a ellas, receptores broadcast recibiendo)
- Procesos *visibles* (actividades pausadas y servicios enlazados a ellas)
- Procesos *de servicio* (servicios no enlazados a actividades)
- Procesos *background* (actividades paradas)
- Procesos *vacíos* (truco de Android, JVM vacías que agilizan el arranque de procesos nuevos)

> [!faq] Se comienza eliminando procesos de la lista por abajo
> Un proceso *foreground* no será eliminado salvo por emergencias.
> 


### Hilos y actividades
La actividad se ejecuta.
- Un hilo atiende eventos de la interfaz de usuario.
- Si son necesarias comunicaciones de red, deben lanzarse en otro hilo
- Android proporciona la clase `AsyncTask` para implementar tareas que deban ser ejecutadas en otro hilo.
- El hilo del GUI **se detiene** si la actividad es *pausada* o *detenida*.
	- Es destruido y creado de nuevoa nte un cambio de configuración (ej. cambio de orientación)

> [!warning] Servicios
> La aplicación puede tener, además de actividades, componentes de tipo servicio, que no son detenidos cuando la actividad se pausa o detiene.

# Servicios
## Problemas
Puesto que la aplicación puede ser terminada sin previo aviso, el uso de servicios web es conflictivo:
- **Problema 1:** si se elimina el proceso en background ANTES de que se procese una petición `GET`, se pierde la petición.
	- *El problema no es muy grave. Cuando la aplicación se cargue de nuevo, se hará el `GET`.*
- **Problema 2:** si se elimina el proceso en background DESPUÉS de que se procese la petición `GET` pero ANTES de devolverla, se pierde la información recibida y procesada.
	- *El problema es desperdicio de CPU y ancho de banda: al solución es almacenar de forma persistente (`ContextProvider`) para cuando la app sea cargada de nuevo.*
- **Problema 3:** si se elimina una actividad que ha enviado una petición `POST` antes de que el servidor responda, se pierde la petición.

## Estrategias
La solución depende de la plataforma:

**Android**
- *Services* para implementar las comunicaciones y procesamiento en *background*.
- *Content providers* para almacenar las respuestas ya procesadas y mantener una cache en memoria para acceso rápido (y no penalizar la velocidad)
- Mantener en el *content provider* el estado de la transacción (mediante constantes). La actividad puede consultar el estado de las transacciones gracias a esto.

# Eficiencia
> [!error] La antena (datos/wifi) es una fuente de consumo importante y debe reducirse su uso.

La antena no está permanentemente consumiendo energía. Tiene tres estados:
- **Standby:** ni transmite ni recibe → consumo mínimo. Pasar a *full power* requiere tiempo y energía.
- **Full power:** transmite o recibe → consumo máximo.
- **Low power:** ni transmite ni recibe → consumo medio. Pasar a *full power* requiere <u>menos</u> tiempo y energía.

Para optimizar el consumo, tras una comunicación se mantiene la antena en *full* durante un tiempo antes de pasar a *low* y finalmente a *standby*.

![[_resources/Pasted image 20231129182345.png]]

**Dilema: ¿qué es preferible?**
1. **Unbundled transfers:** *transmitir* datos solo cuando se necesiten: paquetes pqueños, pero frecuentes → baja latencia para el usuario.
2. **Bundled transfers:** sgrupar transferencias y planificar cuándo hacerlas: paquetes grandes, poco frecuentes. Uso de *prefetching* para disminuir latencia.

![[_resources/Pasted image 20231129183343.png]]
*Claramente, la segunda estrategia es mejor para el consumo de batería.*

## Estrategias
- Usar *prefetching* (difícil equilibrio, pues también se malgasta espacio y bandwidth)
- Eliminar el *polling* (pasar a protocolos push, tipo XMPP)
- Agrupar transferencias que no sean críticas (*bundle*)
- Usar los momentos en que se deben hacer transferencias críticas para hacer también las acumuladas.

### Prefetching
Aprovechar cuando la antena está activa para precargar datos que previsiblemente el usuario solicitará después.

*¿Cuántos datos precargar?* → depende de la tecnología inalámbrica del dispositivo: GPRS, 3G (x2), 4G (x8), WiFi (sin límite)
*¿Qué datos precargar?* → los datos que el usuario vaya a requerir en los próximos 2-5 minutos.