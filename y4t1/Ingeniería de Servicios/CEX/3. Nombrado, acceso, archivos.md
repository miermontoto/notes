![[_resources/T3-DNS-ssh-ftp.pdf]]

#dns #tld #nameservers #registro

---
# 1. Nombrado

## DNS
*Problema:* convertir nombres de máquinas en IPs
*Solución inicial:* un archivo `hosts.txt`.

> [!warning] Problemas
> - Actualización y distribución manual.
> - Colisiones de nombres.
> - Consistencia.

> [!success] Solución
> Sistema de nombres jerárquico.
> Base de datos distribuida → DNS.

### Arquitectura básica
La arquitectura es cliente/servidor:
- Clientes → *resolvers*
- Servidores → *nameservers*

- [Espacio de nombres](#Espacio de nombres) jerárquico, se representa en un árbol.
- Base de datos distribuida entre muchos servidores.
- Protocolos para cliente/servidor o entre servidores.
### Espacio de nombres

#### Dominios de nivel superior

### Base de datos
<mark style="background: #ADCCFFA6;">Un nombre de dominio es el índice de la BD.</mark>

El contenido de la BD para cada índice es un *Resource Record* (RR) con información como:
- si es un nodo final (host) o una sub-zona.
- si ese nodo es un servidor de nombres.
- la IP de la máquina (← el objetivo principal)
- otros nombres para la máquina (y su nombre canónico).
- la persona de contacto (ICANN WHOIS)
- ...

### Implementación
DNS es una especificación, puede haber diferentes implementaciones. La más usada es `BIND` (*Berkeley Internet Name Domain*)

En la implementación de `BIND` se tienen:
- <mark style="background: #BBFABBA6;">Servidores de nombres</mark> (`named`) ← complejos
- <mark style="background: #FFB86CA6;">Clientes</mark> *resolver*, muy simples. No son un proceso sino una biblioteca que implementan `gethostbyname()`.

### <mark style="background: #BBFABBA6;">Servidor de nombres</mark>
<mark style="background: #ADCCFFA6;">Programa que tiene información completa sobre una zona de la que tiene <u>autoridad</u>. Sus respuestas son definitivas.
</mark>
Al delegar parte de la zona:
- El <mark style="background: #BBFABBA6;">SN</mark> original borra la información referente a la nueva sub-zona.
- El <mark style="background: #BBFABBA6;">SN</mark> de la nueva zona es la nueva autoridad en ella.

Una zona puede tener varios <mark style="background: #BBFABBA6;">NS</mark> → redundancia, seguridad y balanceo de carga.
- *Primario:* obtiene los datos de un fichero local.
- *Secundario:* obtiene los datos de un <mark style="background: #BBFABBA6;">NS</mark> primario.
La única diferencia es el origen de los datos. Ambos pueden ser la *autoridad*.

### <mark style="background: #FFB86CA6;">Resolvers</mark>
<mark style="background: #ADCCFFA6;">Cliente que consulta el servidor de nombres. Su misión es:</mark>
- A petición de un programa, conecta con el <mark style="background: #BBFABBA6;">SN</mark> y hace una consulta.
- Interpreta la respuesta y hace más consultas si es necesario.
- Devuelve la información solicitada.

### Resolución
<mark style="background: #ADCCFFA6;">Proceso por el cual se llega a una respuesta (se encuentra la IP / el nombre no existe).</mark>

> [!info]
> Ya que cada <mark style="background: #BBFABBA6;">NS</mark> almacena solo parte de la BD distribuida, una consulta puede no encontrar la respuesta. Dos alternativas:
> 1. El <mark style="background: #BBFABBA6;">NS</mark> contacta con otros servidores hasta encontrar la respuesta (**consulta recursiva**)
> 2. El <mark style="background: #BBFABBA6;">NS</mark> retorna una referencia a otros servidores para proseguir la resolución (**consulta iterativa**)

### Implementación (en BIND)
La conuslta del <mark style="background: #FFB86CA6;">resolver</mark> siempre es de tipo **recursivo**.
- Se simplifica el código del <mark style="background: #FFB86CA6;">resolver</mark> (es una mera biblioteca)

El <mark style="background: #BBFABBA6;">NS</mark> retorna la respuesta si la tiene, de lo contrario usa una consulta de tipo *iterativo* para hallarla.

### Resolución inversa
- Se define un dominio especial `in-addr.arpa`
- Este dominio tiene NS como cualquier otro dominio.
- El dominio puede estar dividido en zonas delegadas, como cualquier otro dominio.
 > [!info] La idea principal es convertir las IPs en nombres
 > Los nombres de los subdominios de `in-addr.arpa` son números entre $1$ y $255$, que se subdividen en subdominios con nombres numéricos también (ej: `105.33.35.156.in-addr.arpa`)
 
### Cacheado
 Cada <mark style="background: #BBFABBA6;">NS</mark> puede mantener una cache con:
 - Las respuestas que ha servido (incluso las negativas)
 - Las IPs de los <mark style="background: #BBFABBA6;">NS</mark> de otras zonas
Esto evita que tenga que acudir cada vez a los <mark style="background: #BBFABBA6;">NS-Raíz</mark>.

- La caché debe descartarse pasado un cierto timepo, de lo contrario los cambios nunca se propagarían.
- **TTL:** parámetro fijado por el admin de la zona.

# 2. Acceso remoto
## Soluciones
- Terminal de texto
	- Telnet (inseguro)
	- SSH
- Terminal gráfica
	- X-Window (solo servidores Unix)
	- RDP *Remote Desktop Protocol* (solo servidores Windows)
	- RFP *Remote Framebuffer Protocol*

## Telnet
> [!faq] Si esto está vacío, no entra en el examen!!!

## SSH
> [!info] No es tan solo un protocolo de terminal remota. 
> SSH-2 introduce un nuevo nivel de multiplexado de comunicaciones, por encima del puerto TCP: el ***CANAL***.

- Cliente y servidor se conectan por TCP.
- Ambos se autentican mutuamente mediante claves públicas.
- Una vez establecida, la conexión puede transportar varios "canales".
- Cada paquete enviado entre cliente y servidor por SSH lleva un "identificador de canal".
- Todos los paquetes van cifrados con <u>algoritmos acordados en fase de negociación</u>.

*Lo único que va sin cifrar son los mensajes iniciales, donde no va información comprometida.*

### Funcionamiento
1. Establecimiento de una conexión segura entre cliente y servidor.
	- Identificación del servidor
	- Negociación de los algoritmos de cifrado y clave a usar
2. Autenticación del cliente: hay varios métodos para ello y se prueban todos hasta que uno funcione.
3. Creación de los canales ssh
4. Uso de los canales
5. Cierre de la conexión TCP

### Protocolos
- *SSH-TRANS* → fase 1 y transportar información cifrada para el resto de la sesión.
- *SSH-USERAUTH* → fase 2, apoyándose en *SSH-TRANS*.
- *SSH-CONNECT* → fase 3, apoyándose en *SSH-TRANS*.

### Criptografía
**Host key**
- Pareja de clave asimétricas, usada por el servidor.
- Sirve para **autenticar al servidor** ante el cliente.
- Creada por el administrador usando `ssh-keygen`.
- Almacenada en disco.
- Igual para cada sesión.

**User key**
- Pareja de clave asimétricas.
- Sirve para autenticar al cliente ante el servidor (uno de los posibles mecanismos del paso 2)
- Creada por el usuario en la máquina cliente usando  `ssh-keygen`.
- Almacenada en disco.
- Igual para cada sesión.
- <u>La parte pública debe ser copiada al servidor.</u>

**Session key**
- Clave simétrica generada aleatoriamente para la sesión.
- Sirve para cifrar los datos transportados.
- Diferente en cada sesión. Se destruye al final.
- NO se almacena en disco.
- Compartida por cliente y servidor de forma segura (Diffie-Hellman)
*En realidad se usan varias.*

#### El problema de claves públicas
- El cliente necesita la parte pública del *host key*.
- El servidor necesita la parte públcia de *user key*.

Estas cadenas ASCII almacenadas en ficheros →
- Cliente en `~/.ssh/known_hosts`
- Servidor en `~/.ssh/authorized_keys`

### Visión general de la arquitectura
![[_resources/Pasted image 20231018184735.png]]

### Proceso
#### Fase 1 (SSH-TRANS): Establecimiento de conexión
1. El cliente conecta al puerto 22 del server.
2. Cliente y servidor anuncian qué versión de SSH soportan
	- Si no son compatibles, desconectan
	- Si lo son, el resto de la comunicación es binaria en paquetes de formato definido.
3. Cada parte envía a la otra una lista de todos los algoritmos que soportan y se ponen de acuerdo en:
	- Algoritmo de intercambio de llaves
	- Algoritmo de firma por clave pública
	- Algoritmo de cifrado simétrico
	- Algoritmo de MAC
	- Algoritmo de compresión
4. Cliente y servidor acuerdan una clave compartida mediante Diffie-Hellman.
	- Versión modificada que incluye una firma digital con la host key.
	- En este paso, el server envía al client su host key para que pueda verificar la firma, el cual debe confiar en ella.

#### Fase 2 (SSH-USERAUTH): Autenticación del cliente
SSH soporta varios métodos de autenticación. Los dos más importantes son:
##### **Contraseña**
El servidor SSH delega en el operativo servidor la verificación de la clave.

##### **Clave pública**
- **Requisitos previos**: El cliente tiene una pareja de claves, almacenadas en disco duro (el server ha de tener una copia de la parte pública)

- **Protocolo**
	- El cliente envía una copia de su clave pública.
	- El servidor compara las que tiene para ese usuario. Si no la encuentra, genera un fallo de autenticación; de lo contrario, genera un reto numérico y lo cifra con la clave pública del cliente.
	- El cliente recibe el reto cifrado, lo descifra y realiza una serie de operaciones prefijadas y envía el resultado al servidor.
	- El servidor compara lo que recibe con lo que ha obtenido él mismo. Si coinciden, la autenticación ha tenido éxito.

**<mark style="background: #BBFABBA6;"><b>Ventajas</b></mark>
- Muy seguro (nunca se transmite ningún secreto)
- Configurable en el lado del servidor

<mark style="background: #FF5582A6;"><b>Desventajas</b></mark>
- Para descifrar el reot, el cliente necesita acceso a su clave privada, que está protegida, por lo que el usuario necesita meter una contraseña de todas formas.

##### SSH: Agentes
Un agente es un proceso en ejecución que puede mantener una copia *en memoria* de las claves privadas.

- Al añadir una clave privada al agente, este la lee del disco (con contraseña) y la almacena en RAM.
- Cuando el cliente la necesite, se la pide al agente *a través de un socket en localhost*.
- El agente le proporciona la clave privada sin volver a preguntar.

#### Fase 3 (SSH-CONNECT): Creación de canales
La creación del canal puede iniciarse desde cualquiera de los extremos, mediante un protocolo específico.
- Se elige un número *libre* del canal.
- Se envía un mensaje especial solicitando apertura
- El otro extremo responde aceptando o denegando su creación

Todos los canales se multiplexan en la misma conexión TCP
- Cada paquete que SSH intercambia contiene el identificador del canal al que pertenece.
- Todos van cifrados y opcionalmente comprimidos.
- Cada uno puede servir para una funcionalidad diferente.

![[_resources/Pasted image 20231025181748.png]]
## Transferencia de archivos
**Objetivos**
- Examinar los archivos en una carpeta remota
- Borrar, renombrar dichos archivos
- Transferidos al ordenador local
- Enviar archivos desde el ordenador local

**Interfaces**
- Se requiere un cliente específico
- Usa el propio sistema de archivos del cliente

**Clientes**
- FTP
- scp
- sftp
- FTPS

**Sistema de archivos del cliente**
- NFS
- SMB
- samba
- sshfs


### FTP

### scp / sftp
#### scp
- Durante la creación del canal se usarán los métodos de autenticación de ssh
- No permite crear directorios remotos, ni listar contenidos, ni cambiar de directorio.
- La transferencia siempre es binaria, cifrada y opcionalmente comprimida.